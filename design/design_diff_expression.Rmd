---
title: "Design: diff_expression()"
author: "Haocheng"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

## Objective

Update and replace the `cal_diff_limma()` function from `rnaseqTools` to use a `HermesData` object and a string with factor name for comparison as input.

## Consideration: where to filter out low expression genes, as well as samples with low depth or technical failure from subsequent workflow

In the `rnaseqTools` vignettes `pg101_example_voom.Rmd`, the authors suggest to filter out low expression genes, as well as samples with low depth or technical failure from subsequent workflow. As we directly take a `HermesData` as object, users cannot manually take filtering.  
 
## Idea

- To make the function easy to use, we only need users to input a `HermesData` object. 
- The `diff_expression()` function extracts the count assay from the `HermesData` object. (The function only accepts un-normalized counts assay for analysis.)
- It also warns the user if there are samples or genes which have failed flags. 
- In addition, we only need users to input a string with factor name in colData for the `HermesData` object. The `diff_expression()` function generates the corresponding design component.  
- We may create helper functions to transfer the `HermesData` object and the factor compatible to run `limma` and `DESeq2` methods, respectively.
  - If the method is `limma`, the `diff_expression()` runs `limma::voom`, `limma::lmFit` and `limma::eBayes` sequentially to obtain a data frame in the class `HermesDataDiffExpr`.
  - If the assay is `deseq2`, the `diff_expression()` runs `DESeq` to obtain a data frame in the class `HermesDataDiffExpr`.
- We use `autoplot()` functions for plotting the `HermesDataDiffExpr` data. 

## Workflow

Later the user would proceed like this maybe:
- first create, add flags, filter the `HermesData` object
- then do `diff_expression()` on it, choose the method as argument
- then apply `autoplot()` on the result to obtain e.g. volcano plot
  - implies that we need to have e.g. `HermesDataDiffExpr` object as result of function call above

## Prototypes

Example:

```{r}
object <- HermesData(summarized_experiment) %>%
  add_quality_flags() %>%
  filter() 
```


### Class

```{r}
.HermesDataDiffExpr <- setClass(
  Class = "HermesDataDiffExpr",
  contains = "data.frame"
)
```


### `diff_expression()`

```{r}
diff_expression <- function(object,
                            group,
                            method = c("limma_voom", "deseq2")) {
  assert_that(
    is_hermes_data(object),
    is.string(group)
  )
  df <- as.data.frame(colData(object))
  assert_that(
    tern::is_df_with_nlevels_factor(df = df, variable = group, n_levels = 2L)
  )
  method <- match.arg(method, c("limma_voom", "deseq2"))
  
  qc_flag <- c(
    rowData(object)$LowExpressionFlag,
    object$LowDepthFlag,
    object$TechnicalFailureFlag
  )
  
  # QC flag should not have NA. If there is any NA or any flag = TRUE, show warnning message)
  if (anyNA(qc_flag) || any(qc_flag)) {
    warning("please ensure that you add QC flags and filter based on them before DE analysis")
  }
  
  group_var <- colData(object)[[group]]
  obj_count <- counts(object)

  result <- if(method == "limma_voom") {
    h_diff_expr_limma(obj_count, group_var)
  } else {
    h_diff_expr_deseq2(obj_count, group_var)
  }
  .HermesDataDiffExpr(result)
}
```

### Analysis using limma package

```{r}
h_diff_expr_limma <- function(obj_count, group_var) {
  
  obj_count_voom <- limma::voom(obj_count)
  design <- model.matrix(~ group_var)  
  fit <- limma::lmFit(obj_count_voom, design)
  eb <- limma::eBayes(fit)
  limma::topTable(eb, coef = 2, n = nrow(obj_count_voom), sort.by="p" ) ## use adj p-value to sort
}

```


## Analysis using DESeq2 package

try to obtain the same result structure - data frame with these columns above
 
```{r}
h_diff_expr_deseq2 <- function(obj_count, group_var) {
  
  cond <- factor(group_var)
  dds <- DESeqDataSetFromMatrix(obj_count, DataFrame(cond), ~ cond)
  dds <- DESeq(dds)
  dds_res <- data.frame(results(dds))
  dds_res <- dds_res[order(dds_res$padj),] ## use adj p-value to sort
  
  ### rename log2FoldChange to logFC
  ### rename pvalue to P.Value
  ### rename padj to adj.P.Val
  ### make the name consistent to limma_voom result
  colnames(dds_res) <- c("baseMean", "logFC", "lfcSE", "stat", "P.Value", "adj.P.Val") 
}

```

## autoplot for vacano plot
```{r}
library(ggrepel)

setMethod(
  f = "autoplot",
  signature = signature(object = "HermesDataDiffExpr"),
  definition = function(object,
                        adj.P.Val.threshold = 0.05,
                        logFC.threshold = 2.5) {
    
      object$difexpr <- "NO"
      object$difexpr[object$logFC > abs(logFC.threshold) &
                           object$adj.P.Val < adj.P.Val.threshold] <- "UP" 
      object$difexpr[object$logFC < -abs(logFC.threshold) &
                           object$adj.P.Val < adj.P.Val.threshold] <- "DOWN"
      
      object$label <- NA
      object$label[object$difexpr != "NO"] <- rownames(object)[object$difexpr != "NO"]
    
      ggplot(data=object, 
             aes(x=logFC, 
             y=-log10(adj.P.Val), 
             col=difexpr,
             label=label)
      ) +
      geom_point() + 
      theme_minimal() + 
      geom_text_repel() +
      xlab("log2 fold change") + 
      ylab("-log10 adjusted p-value") +
      geom_vline(xintercept=c(-abs(logFC.threshold), abs(logFC.threshold)), col="black") +
      geom_hline(yintercept=-log10(adj.P.Val.threshold), col="black")
  }
)
```