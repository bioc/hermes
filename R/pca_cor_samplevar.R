#' Calculation of R2
#'
#' This function calculates R2 between one sample variable from [AnyHermesData] and Principal Component matrix.
#'
#' @param pca (`matrix`)\cr A matrix comprising of principal components matrix generated by [calc_pca()] function.
#'   function.
#' @param x (`vector`)\cr A vector with one sample variable from [AnyHermesData] object.
#'
#' @return A vector with R2 values for each principal component for the sample variable of interest from [AnyHermesData]
#'   object.
#'
#' @importFrom stats model.matrix
#' @importFrom limma lmFit
#'
#' @export
#'
#' @examples
#' object <- HermesData(summarized_experiment) %>%
#'  add_quality_flags() %>%
#'  filter() %>%
#'  normalize()
#' pca <- calc_pca(object)$x
#' x <- colData(object)$LowDepthFlag
#' r2 <- h_pca_var_rsquared(pca, x)
#'  
h_pca_var_rsquared <- function(pca, x) {
  assert_that(
    is.matrix(pca),
    is.numeric(x) || is.factor(x) || is.character(x) || is.logical(x),
    identical(length(x), nrow(pca)),
    all(abs(colMeans(pca)) < 1e-10)
  )
  use_sample <- !is.na(x)
  x <- x[use_sample]
  pca <- pca[use_sample, ]
  design <- stats::model.matrix(~ x)
  # Transpose such that PCs are in rows, and samples in columns.
  y0 <- t(pca)
  fit <- limma::lmFit(y0, design = design)
  ## Compute total sum of squares
  sst <- rowSums(y0^2)
  ## Compute residual sum of squares
  ssr <- sst - fit$df.residual * fit$sigma^2
  r2 <- ssr / sst
  r2
}


#' Generate R2 values for all sample variables
#'
#' This function processes sample variables from [AnyHermesData] and the corresponding principal component matrix, and
#' then generates R2 values for all sample variables in [AnyHermesData] object, giving correlations between all sample
#' variables in [AnyHermesData] object and the principal components of the samples.
#'
#' @param pca (`matrix`)\cr A matrix comprising of principal components matrix generated by [calc_pca()] function.
#' @param df (`dataframe`)\cr A dataframe with sample data [colData] from [AnyHermesData] object.
#'
#' @return A matrix with R2 values for all sample variables in [AnyHermesData] object.
#'
#' @export
#'
#' @examples
#' object <- HermesData(summarized_experiment) %>%
#'  add_quality_flags() %>%
#'  filter() %>%
#'  normalize()
#' pca <- calc_pca(object)$x
#' r2_all <- h_pca_df_r2_matrix(pca, as.data.frame(colData(object)))
#' 
h_pca_df_r2_matrix <- function(pca, df) {
  assert_that(
    is.matrix(pca),
    is.data.frame(df),
    identical(nrow(pca), nrow(df))
  )
  # Sequentially filter down the columns in `df`.
  # Sample variable must be numeric, character, factor or logical.
  is_accepted_type <- vapply(df, function(x) {
    is.numeric(x) || is.character(x) || is.factor(x) || is.logical(x)
  }, TRUE)
  df <- df[, is_accepted_type]
  # Sample variable cannot be completely `NA`
  is_all_na <- vapply(df, all_na, TRUE)
  df <- df[, !is_all_na]
  # Sample variable cannot have a constant value
  is_all_constant <- vapply(df, is_constant, TRUE)
  df <- df[, !is_all_constant]
  # Filter character or factor sample variable that has too many (more than half the number of samples) unique values
  too_many_levels <- vapply(df, function(x) {
    (is.character(x) || is.factor(x)) && (length(unique(x)) > nrow(df)/2)
  }, TRUE)
  df <- df[, !too_many_levels]
  # On all remaining columns, run R2 analysis vs. all principal components.
  vapply(
    X = df,
    FUN = h_pca_var_rsquared,
    pca = pca,
    FUN.VALUE = rep(0.5, ncol(pca))
  )
}

# HermesDataTopGenes ----
#' @rdname correlate
#' @aliases HermesDataPcaCor
#' @aliases correlate
#' @exportClass HermesDataPcaCor
.HermesDataPcaCor <- setClass(
  Class = "HermesDataPcaCor",
  contains = "matrix"
)

setGeneric("correlate", function(object_pca, ...) {})

#' Correlate
#' 
#' Method to generate correlation between all sample variables in [AnyHermesData] object and the principal components of
#' the samples.
#'
#' @describeIn correlate Method to obtain [HermesDataPcaCor] object with R2 values for all sample variables in
#'   [AnyHermesData] object, giving correlations between all sample variables in [AnyHermesData] object and the
#'   principal components of the samples.
#'
#' @param object_pca (`HermesDataPca`)\cr input. It can be generated using [calc_pca()] function on [AnyHermesData].
#' @param data object (`AnyHermedData`)\cr input.
#'
#' @return A [HermesDataPcaCor] object with R2 values for all sample variables.
#' 
#' @export
#'
#' @examples
#' object <- HermesData(summarized_experiment) %>%
#'  add_quality_flags() %>%
#'  filter() %>%
#'  normalize()
#' object_pca <- calc_pca(object)
#' result <- correlate(object_pca, object)
#' 
setMethod(
  f = "correlate",
  signature = c(object_pca = "HermesDataPca"),
  definition = function(object_pca, data) {
    pca <- object_pca$x
    assert_that(
      is_hermes_data(data),
      is(object_pca, "HermesDataPca"),
      identical(rownames(pca), colnames(data))
    )
    df <- as.data.frame(colData(data))
    r2_matrix <- h_pca_df_r2_matrix(pca, df)
    .HermesDataPcaCor(r2_matrix)
  }
)

# autoplot ----

setGeneric("autoplot")

#' @describeIn correlate This plot method uses the [ComplexHeatmap::Heatmap()] function to plot the correlations between
#'   samples variables in [AnyHermesData] object and the principal components of the samples saved in a [HermesDataPcaCor]
#'   object.
#'
#' @param object (`HermesDataPcaCor`)\cr Generated using [correlate] method.
#' @param cor_colors (`function`)\cr color scale function for the correlation values in the heatmap, 
#'   produced by [circlize::colorRamp2()].
#' @param cluster_columns (`function`)\cr Indicate whether re-ordering of columns is desired.
#' @param ... other arguments to be passed to [ComplexHeatmap::Heatmap()].
#'
#' @examples
#' autoplot(result)
#' 
setMethod(
  f = "autoplot",
  signature = c(object = "HermesDataPcaCor"),
  definition = function(object,
                        cor_colors = circlize::colorRamp2(c(-0.5, -0.25, 0, 0.25, 0.5, 0.75, 1), c("blue", "green", "purple", "yellow", "orange", "red", "brown")),
                        cluster_columns = FALSE, 
                        ...) {
    ComplexHeatmap::Heatmap(
      matrix = t(object),
      col = cor_colors,
      name = "R2",
      cluster_columns = FALSE,
      ...
    )
  }
)
