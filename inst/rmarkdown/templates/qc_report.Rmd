---
params:
  
  title:
    label: "Title of the report"
    value: "QC Report"
    input: text
  author: 
    label: "Author(s) of the report: <NAME> (Team/Department i.e. PDD DSX)"
    value: "PDD - Data Science Acceleration (DSX)"
    input: text
  input_data_object:
    label: "[REQUIRED] data object input."
    value: "/home/rstudio/NEST/hermes/data/summarized_experiment.rda"
    input: file
  Hermes_QC_output_dir:
    label: "[REQUIRED] Path to Hermes QC output directory (this is the only requried parameter of the report)"
    value: "/home/"  # "~/XX/XXX"
    input: file
  min_cpm:
    label: "min_cpm (non-negative `number`) minimum CPM for each gene within the sample."
    value: 1 # default 1
    input: numeric
  min_cpm_prop:
    label: "min_cpm_prop (`proportion`) minimum percentage of samples with acceptable CPM of certain gene for low expression flagging."
    value: 0.25
    input: numeric
  min_corr:
    label: "min_corr (`proportion`) minimum Pearson correlation coefficient of CPM between samples for technical failure flagging."
    value: 0.5
    input: numeric
#  min_depth:
#    label: "min_depth (non-negative `count` or `NULL`)\cr minimum library depth for low depth flagging. If `NULL`, this will be calculated as the first quartile minus 1.5 times the inter-quartile range of the library size (depth) of all samples. (So anything below the usual lower boxplot whisker would be too low.)"
#    value: NULL
#    input: numeric
title: "`r params$title`"
author: '`r params$author`'
date: '`r format(Sys.time(), "%d %B %Y")`'
output:
  html_document:
    self_contained: true
    code_folding: hide
    mathjax: default
    number_sections: true
    theme: yeti
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
editor_options:
  chunk_output_type: console
---
```{r setup, message = FALSE}
# -----------------------------------------------------------------------------
# Developer

# The name and version of this report template (printed in last section)
#templateName <- params$title
templateName <- "qc_report"
templateVersion <- "1.0.0"
# Set TRUE to enable rmarkdown cache
knitr::opts_chunk$set(cache = FALSE, cache.lazy = FALSE)
# Set FALSE to skip all output (plots, tables), useful for debugging 
showOutput <- TRUE

# -----------------------------------------------------------------------------

# Knitr options (important to set error=FALSE, otherwise the evaluation does not stop after an error!)
knitr::opts_chunk$set(eval = TRUE, echo = TRUE, message = TRUE, warning = TRUE, error = FALSE)

# Libraries
library(hermes)
```

```{r initialize}
# Check that required parameters were set by user
#requiredPaths <- c("biokit_output_dir")
#checkPathsExist(params, requiredPaths)
#requiredParams <- c("color_vars")
#checkParamsNotEmpty(params, requiredParams)

# -----------------------------------------------------------------------------
```

```{r}
# Load Data and get object HermesData 
obj_name <- load(params$input_data_object)
se <- get(obj_name)
result <- HermesData(se)
#, params$min_depth
control <- control_quality(params$min_cpm, params$min_cpm_prop, params$min_corr)
result_qc <- add_quality_flags(result, control)
```

# Dataset Summary

The data set was composed of `r ncol(result)` samples and `r nrow(result)` genes. 

# Technical Metrics

## Histogram of Library Sizes

First, we check how the distribution of library sizes looks like across all samples. The median library size is <b>`r sprintf("%0.3G", median(colSums(counts(result))))`</b>. 
According to [Standards, Guidelines and Best Practices for RNA-Seq (The ENCODE Consortium)](https://www.encodeproject.org/documents/cede0cbe-d324-4ce7-ace4-f0c3eddf5972/@@download/attachment/ENCODE%20Best%20Practices%20for%20RNA_v2.pdf "ENCODE Project Homepage"), the sequencing depth/library size is usually determined by the goals of the experiment and the nature of the RNA sample. The minimum library size required is around 20-30 million aligned reads. 

```{r genes_hist_libdepth,results='asis'}
draw_libsize_hist(result)
```

## Q-Q Plot of Library Sizes

The distribution of library sizes is then compared to the normal distribution. The linearity of the points will suggest if the distribution of library sizes is normally distributed.

```{r genes_qqplot_libdepth, results = 'asis'}
draw_libsize_qq(result)
```

## Density Plot of (Log) Counts Distributions

In this plot, each line represents density of expression of all the genes within one sample. Lines that deviate from the majority may suggest inconsistent read depth or technical failure of the samples. The peaks in log2 (count) distribution indicate the log2(count) value at which the majority of genes are expressed. 

```{r genes_density_libdepth, results = "asis"}
draw_libsize_densities(result)
```

# Gene filtering

This step is necessary to flag out genes with low expression. Genes with very low counts across all libraries provide little evidence for differential expression and they interfere with some of the statistical analyses conducted later in the pipeline. Therefore, these genes should be filtered out prior to the analysis. 

There are many ways to filter out genes with lower counts. When there are n biological replicates in each group, we usually filter on a minimum counts per million threshold present in at least n samples. In this dataset, we choose to retain genes if they are expressed at a counts-per-million (CPM) above <b> `r params$min_cpm` </b>

<b>`r h_low_expression_flag(result)`</b>

## Boxplot of Non-zero Genes

This boxplot shows overlaid data points, of the number of non-zero expressed genes per sample.

```{r}
draw_nonzero_boxplot(result)
```

## Stacked Barplot of Low Expression Genes by Chromosome

This barplot shows the chromosomes with their proportions of low expression genes.

```{r}
draw_genes_barplot(result)
```

## Genes with extremely high counts
# missing not in graph.R
```{r}

# For reference rnaseqTool results
# in Hermes draw_top_barplot
#gSE <- eset2gSE(example_ExpressionSet)
#draw_top_gene(gSE = gSE.postqc,
 #             subset = Chromosome %in% as.character(c(1:22)),
  #            FUN = function(x) {sqrt(rowVars(x))}, 
   #           par_opts = list(main = "Top 10 most variable autosome genes", 
    #                          xlab = "HGNC gene names", 
     #                         ylab = "CPM Standard Deviation", 
      #                        cex.names = 0.5))
```


## Genes with highest variability
# missing not in graph.R
```{r}
draw_top_gene(gSE = gSE.postqc,
              subset = Chromosome %in% as.character(c(1:22)),
              FUN = function(x) {sqrt(rowVars(x))}, 
              par_opts = list(main = "Top 10 most variable autosome genes", 
                              xlab = "HGNC gene names", 
                              ylab = "CPM Standard Deviation", 
                              cex.names = 0.5))
```



```{r}

# For reference rnaseqTool results
#gSE <- eset2gSE(example_ExpressionSet)
#gse.qc <- gQCproc(gSE)
#gse.postqc <- subset(gse.qc, LowExpressionFlag == 0, LowDepthFlag == 0 & TechnicalFailureFlag == 0)
#getmeta(rowData(gse.postqc), "threshold.cpm")
#draw_top_gene(gSE = gSE.postqc)
```

# Sample filtering

This step is necessary to flag out samples with low depth or technical failure. There are three approaches:   






3. Boxplots of non-zero count genes in each sample  
    In this plot, each data point represents the number of non-zero genes in a sample. Samples with a lower number non-zero count genes may be also of interest. 
    



<!-- ---------------------------------------------------------------------- -->
<!-- Prints the parameters and session information                          -->
<!-- Include at end of each biokitr report                                  -->
<!-- ---------------------------------------------------------------------- -->
```{r session_info, results = "asis"}
#printReproducibilitySection(params, templateName, templateVersion)   
```
